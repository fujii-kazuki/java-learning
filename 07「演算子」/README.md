# 演算子
Javaの演算子はRubyやJavaScriptで扱う演算子の復習の様な内容のため、この学習は簡潔にまとめる。

## 算術演算子

### 整数と浮動小数点数との演算
Javaでは算術演算子を使った演算を行うとき、次のルールに従って**型変換**を行った上で演算を行う。

1. どちらかの値がdouble型の場合は他の値をdouble型に変換する
2. どちらかの値がfloat型の場合は他の値をfloat型に変換する
3. どちらかの値がlong型の場合は他の値をlong型に変換する
4. (1)から(3)に該当しない場合は両方の値をint型に変換する

この様な性質上、注意が必要となるのが**除算**を行う場合。  
下記の様に計算に使用する値のデータ型がint型のみの場合は、計算結果の値のデータ型もint型となる。そのため、例えば**10/4の結果が2.5ではなく2**となってしまい意図した結果が得られない事があるので注意。
```
System.out.println(10 / 4);      // 2
System.out.println(10.0 / 4.0);  // 2.5
System.out.println(10 / 4.0);    // 2.5
System.out.println(10.0 / 4);    // 2.5
```

この様な場合、どちらかの数値を**キャスト演算子**を使ってdouble型に変換するとdouble型で演算を行なった場合の結果を得る事ができる。
```
int num1 = 10;
int num2 = 4;
System.out.println(num1 / (double)num2);  //2.5
```

### ゼロで除算したときの結果について
型によって0で割った場合の結果が異なる。
```
// int型
int i = 10 / 0;   //実行時にエラー
int j = 10 % 0;   //実行時にエラー

// double型、float型
double d = 10.0 / 0;
System.out.println(d);  //0で割るとInfinity
float f = 10.0F % 0;
System.out.println(d);  //0で割った余りはNaN
```

## 単項マイナス演算子
数値の正と負を反転させるために使用する。  
シンプルだが、**short型やbyte型の値に対して単項マイナス演算子を使用する際は注意が必要。**
```
short s1 = 12;
short s2 = -s1;   //エラー
```
short型の変数`s1`に単項マイナス演算子を使用して符号を反転したものをshort型の変数`s2`に代入しようとしていますが、コンパイルエラーとなる。  
これは**単項マイナス演算子を使用することで型変換のルールが適用されてs1がint型に自動的に型変換される**ため。  
その結果`-s1`はint型の値となるため、short型の変数に代入するには**明示的な型変換（キャスト演算子）**が必要となる。
```
short s1 = 12;
short s2 = (short)-s1;    //OK
``` 

## ビット演算子
整数方の値に論理演算を行うための演算子。次の演算子が用意されている。

| 演算子 | 使用例 | 意味 |
| --- | --- | --- |
| `&` | a & b | aとbの論理積（ビットAND） |
| `\|` | a \| b | aとbの論理和（ビットOR） ｜
| `^` | a ^ b | aとbの排他的論理和（ビットXOR） |
| `~` | ~a | aのビット反転（ビットNOT） |
| `<<` | a << n | aを左へnビットシフト |
| `>>` | a >> n | aを右へnビットシフト（符号あり） |
| `>>>` | a >>> n | aを右へnビットシフト（符号なし） |

### 論理積（ビットAND）
演算子の左辺と右辺の同じ位置にあるビットを比較して、両方のビットが共に1の場合だけ1にする。

使用例
```
int i;
i = 85 & 15;  //i = 5
```

解説（括弧の中は16進数）
```
0000 0000 0000 0000 0000 0000 0101 0101 = 85(0x55)
0000 0000 0000 0000 0000 0000 0000 1111 = 15(0x0F)
--------------------------------------------------
0000 0000 0000 0000 0000 0000 0000 0101 = 5(0x05)
```
演算子の左辺と右辺の値をビット単位で比較し、どちらも1だった場合だけ1とし、それ以外は0とする。  
演算の結果は5となり、変数iには5が代入される。