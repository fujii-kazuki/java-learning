- [演算子](#演算子)
  - [算術演算子](#算術演算子)
    - [整数と浮動小数点数との演算](#整数と浮動小数点数との演算)
    - [ゼロで除算したときの結果について](#ゼロで除算したときの結果について)
  - [単項マイナス演算子](#単項マイナス演算子)
  - [ビット演算子](#ビット演算子)
    - [論理積（ビットAND）](#論理積ビットand)
    - [論理和（ビット論理和）](#論理和ビット論理和)
    - [排他的論理和（ビットXOR）](#排他的論理和ビットxor)
    - [反転（ビットNOT）](#反転ビットnot)
  - [シフト演算子](#シフト演算子)
    - [左シフト](#左シフト)
    - [右シフト](#右シフト)
    - [右シフト（符号なし）](#右シフト符号なし)

# 演算子
Javaの演算子はRubyやJavaScriptで扱う演算子の復習の様な内容のため、この学習は簡潔にまとめる。

## 算術演算子

### 整数と浮動小数点数との演算
Javaでは算術演算子を使った演算を行うとき、次のルールに従って**型変換**を行った上で演算を行う。

1. どちらかの値がdouble型の場合は他の値をdouble型に変換する
2. どちらかの値がfloat型の場合は他の値をfloat型に変換する
3. どちらかの値がlong型の場合は他の値をlong型に変換する
4. (1)から(3)に該当しない場合は両方の値をint型に変換する

この様な性質上、注意が必要となるのが**除算**を行う場合。  
下記の様に計算に使用する値のデータ型がint型のみの場合は、計算結果の値のデータ型もint型となる。そのため、例えば**10/4の結果が2.5ではなく2**となってしまい意図した結果が得られない事があるので注意。
```
System.out.println(10 / 4);      // 2
System.out.println(10.0 / 4.0);  // 2.5
System.out.println(10 / 4.0);    // 2.5
System.out.println(10.0 / 4);    // 2.5
```

この様な場合、どちらかの数値を**キャスト演算子**を使ってdouble型に変換するとdouble型で演算を行なった場合の結果を得る事ができる。
```
int num1 = 10;
int num2 = 4;
System.out.println(num1 / (double)num2);  //2.5
```

### ゼロで除算したときの結果について
型によって0で割った場合の結果が異なる。
```
// int型
int i = 10 / 0;   //実行時にエラー
int j = 10 % 0;   //実行時にエラー

// double型、float型
double d = 10.0 / 0;
System.out.println(d);  //0で割るとInfinity
float f = 10.0F % 0;
System.out.println(d);  //0で割った余りはNaN
```

## 単項マイナス演算子
数値の正と負を反転させるために使用する。  
シンプルだが、**short型やbyte型の値に対して単項マイナス演算子を使用する際は注意が必要。**
```
short s1 = 12;
short s2 = -s1;   //エラー
```
short型の変数`s1`に単項マイナス演算子を使用して符号を反転したものをshort型の変数`s2`に代入しようとしていますが、コンパイルエラーとなる。  
これは**単項マイナス演算子を使用することで型変換のルールが適用されてs1がint型に自動的に型変換される**ため。  
その結果`-s1`はint型の値となるため、short型の変数に代入するには**明示的な型変換（キャスト演算子）**が必要となる。
```
short s1 = 12;
short s2 = (short)-s1;    //OK
``` 

## ビット演算子
整数方の値に論理演算を行うための演算子。次の演算子が用意されている。

| 演算子 | 使用例 | 意味 |
| --- | --- | --- |
| `&` | a & b | aとbの論理積（ビットAND） |
| `\|` | a \| b | aとbの論理和（ビットOR） ｜
| `^` | a ^ b | aとbの排他的論理和（ビットXOR） |
| `~` | ~a | aのビット反転（ビットNOT） |
| `<<` | a << n | aを左へnビットシフト |
| `>>` | a >> n | aを右へnビットシフト（符号あり） |
| `>>>` | a >>> n | aを右へnビットシフト（符号なし） |

### 論理積（ビットAND）
演算子の左辺と右辺の同じ位置にあるビットを比較して、両方のビットが共に1の場合だけ1にする。

例
```
int i;
i = 85 & 15;  //i = 5
```

解説（括弧の中は16進数）
```
0000 0000 0000 0000 0000 0000 0101 0101 = 85(0x55)
0000 0000 0000 0000 0000 0000 0000 1111 = 15(0x0F)
--------------------------------------------------
0000 0000 0000 0000 0000 0000 0000 0101 = 5(0x05)
```
演算子の左辺と右辺の値をビット単位で比較し、どちらも1だった場合だけ1とし、それ以外は0とする。  
演算の結果は5となり、変数iには5が代入される。

### 論理和（ビット論理和）
演算子の左辺と右辺の同じ位置にあるビットを比較して、少なくともどちらか一つのビットが1の場合は1にする。

例
```
int i;
i = 85 | 15;    //i = 95
```

解説
```
0000 0000 0000 0000 0000 0000 0101 0101 = 85(0x55)
0000 0000 0000 0000 0000 0000 0000 1111 = 15(0x0F)
--------------------------------------------------
0000 0000 0000 0000 0000 0000 0101 1111 = 95(0x5F)
```
演算子の左辺と右辺の値をビット単位で比較し、少なくともどちらか一つが１の場合は１とし、それ以外は０とする。  
演算の結果は95となり変数iには95が代入される。

### 排他的論理和（ビットXOR）
演算子の左辺と右辺の同じ位置にあるビットを比較して、どちらかのビット１つだけ１の場合に１にし、両方が１の場合や両方が０の場合は０にする。

例
```
int i;
i = 85 ^ 15;    //i = 90
```

解説
```
0000 0000 0000 0000 0000 0000 0101 0101 = 85(0x55)
0000 0000 0000 0000 0000 0000 0000 1111 = 15(0x0F)
--------------------------------------------------
0000 0000 0000 0000 0000 0000 0101 1010 = 90(0x5A)
```
演算子の左辺と右辺の値をビット単位で比較し、どちらかのビットが1つだけ1の場合に1とし、それ以外は０とする。  
演算の結果は90となり、変数iにには90が代入される。

### 反転（ビットNOT）
演算子の右の値の各ビットを反転させる。具体的には1の場合は0、0の場合は1にする。

例
```
int i;
i = ~85;    //i = -86
```

解説
```
0000 0000 0000 0000 0000 0000 0101 0101 = 85(0x55)
---------------------------------------------------------
1111 1111 1111 1111 1111 1111 1010 1010 = -86(0xFFFFFFAA)
```
上記の様に各ビットを反転した結果である-86が変数iに代入される。  
ちなみに、最上位ビットが1の場合は負の数を表す。

## シフト演算子
ビット演算子の中でも`<<` `>>` `>>>`の3つは**シフト演算子**と呼ばれることもある。

### 左シフト
左シフト`<<`は対象の値を指定した数だけ左へシフトする。
この時左端からははみ出した部分は切り捨てられ、開いた右側の部分には0で埋める。

例
```
int i;
i = 21 << 2;
```

解説
```
0000 0000 0000 0000 0000 0000 0001 0101 = 21(0x15)
--------------------------------------------------------------
0000 0000 0000 0000 0000 0000 0010 1010 = 42(0x2A) 左へ1つシフト
0000 0000 0000 0000 0000 0000 0101 0100 = 84(0x54) 左へ1つシフト
```
指定した数だけ左へビット単位でシフトが行われ、演算の結果である84が変数iに代入される。

### 右シフト
右シフト`>>`は対象の値を指定した数だけ右へシフトする。  
このとき右側からはみ出した部分は捨てられるが、開いた左側の部分にはもともと最上位ビットが1だった場合は1で埋められ、最上位ビットが0だった場合派0で埋められる。（数値の符号を変化させない為）

例
```
int i;
i = 21 >> 2;
```

解説
```
0000 0000 0000 0000 0000 0000 0001 0101 = 21(0x15)
--------------------------------------------------------------
0000 0000 0000 0000 0000 0000 0000 1010 = 10(0x0A) 右へ1つシフト
0000 0000 0000 0000 0000 0000 0000 0101 =  5(0x05) 右へ1つシフト
```
指定した数だけ右へビット単位でシフトが行われ、演算の結果である5が変数iに代入される。

### 右シフト（符号なし）
右シフト（符号なし）`>>>`は対象の値を指定した数だけ右へシフトする。  
このとき右端からはみ出した部分は捨てられるが、開いた左側の部分は元々の最上位ビットの値に関わらず0で埋めれられる。  
**符号ありの右シフトが算術シフト**と呼ばれるのに対して、**符号なしの右シフトは論理シフト**と呼ばれることもある。

例
```
byte b;
b = -92 >>> 2;
```

解説
```
1111 1111 1111 1111 1111 1111 1010 0100 = -92(0xFFFFFFA4)
--------------------------------------------------------------------
0111 1111 1111 1111 1111 1111 1101 0010 = 2147483602(0x7FFFFFD2) 右へ
0011 1111 1111 1111 1111 1111 1110 1001 = 1073741801(0x3FFFFFE9) 右へ
```
指定した数だけ右へビット単位でシフトが行われ、片残の結果である1073741801が変数bに代入される。  
今回の場合は最上位ビットが1でしたが、符号なし右シフトの場合は最上位ビットは0で埋められる。